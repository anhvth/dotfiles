#!/usr/bin/env python3

import argparse
import multiprocessing
import os
import shlex
import subprocess
import pandas as pd
import itertools
import re
import sys
import glob
import json
from speedy import load_by_ext, dump_json_or_pickle

def read_data(file_path):
    ext = os.path.splitext(file_path)[1]
    if ext == '.tsv':
        return pd.read_csv(file_path, sep='\t')
    elif ext == '.json' or ext == '.jsonl':
        return load_by_ext(file_path)
        # with open(file_path, 'r') as file:
            # return json.load(file)
    # elif ext == '.jsonl':
    #     with open(file_path, 'r') as file:
    #         return [json.loads(line) for line in file]
    else:
        raise ValueError("Unsupported file format")

def write_data(data, file_path):
    ext = os.path.splitext(file_path)[1]
    if ext == '.tsv':
        pd.DataFrame(data).to_csv(file_path, sep='\t', index=False)
    elif ext == '.json' or ext == '.jsonl':
        dump_json_or_pickle(data, file_path)        
    else:
        raise ValueError("Unsupported file format")


def extract_output_file(command):
    match = re.search(r'(-o|--output) (\S+)', command)
    if match:
        return match.group(2)
    return None



def get_cmd_to_run(commands):
    return [cmd for cmd in commands if not os.path.exists(extract_output_file(cmd))]

def run_in_tmux(commands_to_run, tmux_name, num_windows):
    subprocess.run(['tmux', 'new-session', '-d', '-s', tmux_name])
    for i, cmd in enumerate(itertools.cycle(commands_to_run)):
        if i >= num_windows:
            break
        window_name = f"{tmux_name}:{i}"
        if i > 0:
            subprocess.run(['tmux', 'new-window', '-t', tmux_name])
        subprocess.run(['tmux', 'send-keys', '-t', window_name, cmd, 'C-m'])

def concatenate_and_save(output_dir, output_file, num_items):
    ext = os.path.splitext(output_file)[1]
    output_files = list(sorted(glob.glob(f"{output_dir}/output_chunk_*{ext}")))
    # Print to check if the files are in the correct order, make the print prettier
    print(f"Concatenating {len(output_files)} files")
    
    output = [None] * num_items
    if ext == '.tsv':
        for i, file in enumerate(output_files):
            this_chunk = pd.read_csv(file, sep='\t', header=None)
            output[i::len(output_files)] = this_chunk.values.tolist()
        pd.DataFrame(output).to_csv(output_file, sep='\t', header=None, index=None)
        
    elif ext in ['.json', '.jsonl']:
        for i, file in enumerate(output_files):
            output[i::len(output_files)] = read_data(file)
        write_data(output, output_file)
    for path in output_files:
        os.remove(path)

def split_input(args):
    args.i = os.path.abspath(args.i)
    args.o = os.path.abspath(args.o)
    input_data = pd.read_csv(args.i, sep='\t')

    gpus = args.gpus.split(',')
    gpus = [gpu for gpu in gpus if gpu not in args.ignore_gpus.split(',')]
    num_gpus = len(gpus)
    cpu_per_process = max(args.total_cpu // args.total_fold, 1)
    f = open(args.tmp_script, 'w')
    tbdelete = []
    input_ext = os.path.splitext(args.i)[1]
    output_ext = os.path.splitext(args.o)[1]

    input_data = read_data(args.i)

    for i in range(args.total_fold):
        gpu = gpus[i % num_gpus]
        cpu_start = (i * cpu_per_process) % args.total_cpu
        cpu_end = ((i + 1) * cpu_per_process - 1) % args.total_cpu
        input_chunk = f'{args.input_dir}/input_chunk_{i}{input_ext}'
        output_chunk = f'{args.output_dir}/output_chunk_{i:04d}{output_ext}'

        if input_ext == '.tsv':
            input_data[i::args.total_fold].to_csv(input_chunk, sep='\t', index=False)
        elif input_ext == '.json':
            write_data(input_data[i::args.total_fold], input_chunk)
        elif input_ext == '.jsonl':
            write_data(input_data[i::args.total_fold], input_chunk)

        tbdelete.extend([input_chunk, output_chunk])

        fold_cmd = f"CUDA_VISIBLE_DEVICES={gpu} taskset -c {cpu_start}-{cpu_end} python {args.cmd[0]} -i {input_chunk} -o {output_chunk}"
        fold_cmd = fold_cmd + '\n' if i < args.total_fold - 1 else fold_cmd + '\n'
        f.write(fold_cmd)
    f.close()
    return len(input_data)

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Process fold arguments')
    parser.add_argument('--total_fold', '-t', default=16, type=int, help='Total number of folds')
    parser.add_argument('--gpus', default="0,1,2,3,4,5,6,7", help='GPU IDs to use')
    parser.add_argument('--ignore_gpus', '-ig', default="", help='GPUs to ignore')
    parser.add_argument('--total_cpu', default=multiprocessing.cpu_count(), type=int, help='Total number of CPU cores')
    parser.add_argument('--input_dir', default="/tmp", help='Directory for input chunks')
    parser.add_argument('--output_dir', default="/tmp", help='Directory for output chunks')
    parser.add_argument('--tmp_script', default="/tmp/cmd.sh", help='Path for temporary shell script')
    parser.add_argument('-i', required=True, help='Input file')
    parser.add_argument('-o', required=True, help='Output file')
    parser.add_argument('cmd', nargs=argparse.REMAINDER, help='Command to run')
    parser.add_argument('--force', '-f', action='store_true', help='Force run all commands')
    
    args = parser.parse_args()
    num_outputs = split_input(args)
    with open(args.tmp_script, 'r') as file:
        commands = file.read().splitlines()
    commands_to_run = commands #get_cmd_to_run(commands) if not args.force else commands
    print('\n'.join(commands_to_run))
    
    run_in_tmux(commands_to_run, 'run', args.total_fold)
    
    import time
    try:
        while len(commands_to_run):
            commands_to_run = get_cmd_to_run(commands)
            time.sleep(5)
            print('Waiting for all intermediate outputs to become available')
        
        if not commands_to_run:
            print("No commands to run. All output files exist.")
            concatenate_and_save(args.output_dir, args.o, num_outputs)
            print(f"Output saved to {args.o}")
    except Exception as e:
        import traceback
        traceback.print_exc()
        print(e)
    finally:
        print('Interrupted')
        # kill all tmux sessions name run
        subprocess.run(['tmux', 'kill-session', '-t', 'run'])
